/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */


export interface paths {
  "/health": {
    /** Health check */
    get: operations["health"];
  };
  "/api/v1/config": {
    /** Get daemon configuration */
    get: operations["getConfig"];
  };
  "/api/v1/qemu/run": {
    /** Run QEMU with configuration */
    post: operations["qemuRun"];
  };
  "/api/v1/qemu/stop": {
    /** Stop QEMU */
    post: operations["qemuStop"];
  };
  "/api/v1/qemu/status": {
    /** Get QEMU status */
    get: operations["qemuStatus"];
  };
  "/api/v1/shell/exec": {
    /** Execute a shell command */
    post: operations["shellExec"];
  };
  "/api/v1/shell/selfcheck": {
    /** Run self-check tests */
    post: operations["shellSelfcheck"];
  };
  "/api/v1/shell/selfcheck/cancel": {
    /** Cancel running self-check */
    post: operations["shellSelfcheckCancel"];
  };
  "/api/v1/replay": {
    /** Start replay from log file */
    post: operations["replayStart"];
  };
  "/api/v1/replay/stop": {
    /** Stop running replay */
    post: operations["replayStop"];
  };
  "/api/v1/replay/status": {
    /** Get replay status */
    get: operations["replayStatus"];
  };
  "/api/v1/metrics/streams": {
    /** List all metric series */
    get: operations["listStreams"];
  };
  "/api/v1/metrics/query": {
    /** Query a specific metric series */
    get: operations["querySeries"];
  };
  "/events": {
    /**
     * WebSocket event stream
     * @description Upgrade to WebSocket for real-time event streaming
     */
    get: {
      responses: {
        /** @description Switching Protocols */
        101: {
          content: never;
        };
      };
    };
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: {
    HealthResponse: {
      /** @example ok */
      status: string;
      /** @example 0.1.0 */
      version: string;
      /** @example 3600 */
      uptime_secs?: number;
    };
    DaemonConfig: {
      /** @description Prompt pattern regex for shell detection */
      promptPattern: string;
      /**
       * Format: int64
       * @description Maximum output bytes per command
       */
      maxOutputBytes: number;
      /**
       * Format: int64
       * @description Retry-After seconds for 409 Conflict responses
       */
      retryAfterSeconds: number;
      /**
       * Format: int64
       * @description High-resolution metrics retention in milliseconds
       */
      metricsHighResRetentionMs: number;
      /**
       * Format: int64
       * @description Downsampled metrics retention in milliseconds
       */
      metricsDownsampleRetentionMs: number;
      /** @description Maximum number of unique metric series */
      metricsCardinalityLimit: number;
      /** @description Path to QEMU run script */
      runScript: string;
      /** @description Default features to enable */
      defaultFeatures: string[];
    };
    QemuConfig: {
      features?: string[];
      env?: {
        [key: string]: string;
      };
      args?: string[];
      working_dir?: string;
    };
    QemuStatus: {
      state: components["schemas"]["QemuState"];
      /** Format: int32 */
      pid?: number | null;
      /** Format: int64 */
      uptime_secs?: number | null;
      features: string[];
      error?: string | null;
      /** Format: int64 */
      lines_processed: number;
      /** Format: int64 */
      events_emitted: number;
    };
    /** @enum {string} */
    QemuState: "idle" | "starting" | "running" | "stopping" | "failed";
    ShellCommandRequest: {
      command: string;
      /** Format: int64 */
      timeout_ms?: number | null;
    };
    ShellCommandResponse: {
      command: string;
      output: string[];
      success: boolean;
      error?: string | null;
      /** Format: int64 */
      execution_time_ms: number;
    };
    SelfCheckResponse: {
      tests: components["schemas"]["TestResultEntry"][];
      total: number;
      passed: number;
      failed: number;
      success: boolean;
      /** Format: int64 */
      execution_time_ms: number;
    };
    TestResultEntry: {
      name: string;
      passed: boolean;
      /** Format: int64 */
      timestamp: number;
    };
    ReplayRequest: {
      /**
       * @description Log source mode
       * @default sample
       * @enum {string}
       */
      mode?: "sample" | "upload";
      /** @description Sample name or file identifier */
      logSource?: string;
      /** @description Base64-encoded log file content (mode=upload only) */
      file?: string;
      /**
       * @description Replay speed
       * @default realtime
       * @enum {string}
       */
      speed?: "instant" | "fast" | "realtime";
      /**
       * @deprecated
       * @description DEPRECATED: Use logSource with mode=sample
       */
      sample?: string;
    };
    ReplayResponse: {
      message: string;
      lines_processed: number;
    };
    ReplayStatus: {
      state: components["schemas"]["ReplayState"];
      source?: string | null;
      mode?: string | null;
      /** @description Progress percentage */
      progress: number;
    };
    /** @enum {string} */
    ReplayState: "idle" | "running";
    /** @description A single metric data point */
    MetricPoint: {
      /**
       * Format: int64
       * @description Unix timestamp in milliseconds
       */
      ts: number;
      /**
       * Format: int64
       * @description Metric value
       */
      value: number;
    };
    /** @description Statistics for a metric series */
    SeriesStats: {
      /** @description Total number of points recorded */
      count: number;
      /**
       * Format: int64
       * @description Minimum value
       */
      min: number;
      /**
       * Format: int64
       * @description Maximum value
       */
      max: number;
      /**
       * Format: double
       * @description Mean (average) value
       */
      mean: number;
      /**
       * Format: int64
       * @description Most recent value
       */
      last_value: number;
    };
    /** @description Metadata for a metric series */
    SeriesMetadata: {
      /** @description Series name */
      name: string;
      /** @description Number of points in series */
      count: number;
      /**
       * Format: int64
       * @description Timestamp of most recent point (ms)
       */
      lastTs: number;
      stats: components["schemas"]["SeriesStats"];
    };
    /** @description Result of a metric query */
    QueryResult: {
      /** @description Series name */
      name: string;
      /** @description Data points */
      points: components["schemas"]["MetricPoint"][];
      /** @description Whether data was downsampled */
      downsampled: boolean;
      /**
       * Format: int64
       * @description Start timestamp (ms)
       */
      from: number;
      /**
       * Format: int64
       * @description End timestamp (ms)
       */
      to: number;
    };
    /** @description RFC 7807 problem+json error response */
    ErrorResponse: {
      /**
       * Format: uri
       * @description URI reference identifying the problem type
       * @example /errors/query-bad-range
       */
      type?: string;
      /** @description Short, human-readable summary */
      title: string;
      /** @description HTTP status code */
      status: number;
      /** @description Human-readable explanation */
      detail: string;
      /**
       * Format: uri
       * @description URI reference to specific occurrence
       */
      instance?: string | null;
      /** @description Error message (legacy field) */
      error: string;
    };
    SuccessResponse: {
      message: string;
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type $defs = Record<string, never>;

export type external = Record<string, never>;

export interface operations {

  /** Health check */
  health: {
    responses: {
      /** @description Service is healthy */
      200: {
        content: {
          "application/json": components["schemas"]["HealthResponse"];
        };
      };
    };
  };
  /** Get daemon configuration */
  getConfig: {
    responses: {
      /** @description Configuration retrieved */
      200: {
        content: {
          "application/json": components["schemas"]["DaemonConfig"];
        };
      };
    };
  };
  /** Run QEMU with configuration */
  qemuRun: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["QemuConfig"];
      };
    };
    responses: {
      /** @description QEMU started successfully */
      200: {
        content: {
          "application/json": components["schemas"]["SuccessResponse"];
        };
      };
      /** @description Invalid configuration */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Failed to start QEMU */
      500: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /** Stop QEMU */
  qemuStop: {
    responses: {
      /** @description QEMU stopped successfully */
      200: {
        content: {
          "application/json": components["schemas"]["SuccessResponse"];
        };
      };
      /** @description Failed to stop QEMU */
      500: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /** Get QEMU status */
  qemuStatus: {
    responses: {
      /** @description QEMU status retrieved */
      200: {
        content: {
          "application/json": components["schemas"]["QemuStatus"];
        };
      };
    };
  };
  /** Execute a shell command */
  shellExec: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ShellCommandRequest"];
      };
    };
    responses: {
      /** @description Command executed successfully */
      200: {
        content: {
          "application/json": components["schemas"]["ShellCommandResponse"];
        };
      };
      /** @description Invalid request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description System busy */
      409: {
        headers: {
          /** @description Seconds to wait before retrying */
          "Retry-After"?: number;
        };
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Execution failed */
      500: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Shell not ready */
      503: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /** Run self-check tests */
  shellSelfcheck: {
    responses: {
      /** @description Self-check completed */
      200: {
        content: {
          "application/json": components["schemas"]["SelfCheckResponse"];
        };
      };
      /** @description System busy */
      409: {
        headers: {
          "Retry-After"?: number;
        };
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Self-check failed */
      500: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Shell not ready */
      503: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /** Cancel running self-check */
  shellSelfcheckCancel: {
    responses: {
      /** @description Self-check canceled */
      200: {
        content: {
          "application/json": components["schemas"]["SuccessResponse"];
        };
      };
      /** @description No self-check running */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Cancel failed */
      500: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /** Start replay from log file */
  replayStart: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ReplayRequest"];
      };
    };
    responses: {
      /** @description Replay started */
      200: {
        content: {
          "application/json": components["schemas"]["ReplayResponse"];
        };
      };
      /** @description Invalid request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Replay already running */
      409: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Replay failed */
      500: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /** Stop running replay */
  replayStop: {
    responses: {
      /** @description Replay stopped */
      200: {
        content: {
          "application/json": components["schemas"]["SuccessResponse"];
        };
      };
      /** @description No replay running */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /** Get replay status */
  replayStatus: {
    responses: {
      /** @description Replay status retrieved */
      200: {
        content: {
          "application/json": components["schemas"]["ReplayStatus"];
        };
      };
    };
  };
  /** List all metric series */
  listStreams: {
    parameters: {
      query?: {
        /** @description Filter by name prefix */
        prefix?: string;
      };
    };
    responses: {
      /** @description List of metric series */
      200: {
        content: {
          "application/json": components["schemas"]["SeriesMetadata"][];
        };
      };
    };
  };
  /** Query a specific metric series */
  querySeries: {
    parameters: {
      query: {
        /** @description Metric name */
        name: string;
        /** @description Start timestamp in milliseconds */
        from?: number;
        /** @description End timestamp in milliseconds */
        to?: number;
        /** @description Maximum number of points to return (100-5000, default 1000) */
        maxPoints?: number;
      };
    };
    responses: {
      /** @description Metric data points */
      200: {
        content: {
          "application/json": components["schemas"]["QueryResult"];
        };
      };
      /** @description Invalid query parameters */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Series not found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
}
