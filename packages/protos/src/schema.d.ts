/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */


export interface paths {
  "/health": {
    /** Health check */
    get: operations["health"];
  };
  "/api/v1/config": {
    /** Get daemon configuration */
    get: operations["getConfig"];
  };
  "/api/v1/qemu/run": {
    /** Run QEMU with configuration */
    post: operations["qemuRun"];
  };
  "/api/v1/qemu/stop": {
    /** Stop QEMU */
    post: operations["qemuStop"];
  };
  "/api/v1/qemu/status": {
    /** Get QEMU status */
    get: operations["qemuStatus"];
  };
  "/api/v1/shell/exec": {
    /** Execute a shell command */
    post: operations["shellExec"];
  };
  "/api/v1/shell/selfcheck": {
    /** Run self-check tests */
    post: operations["shellSelfcheck"];
  };
  "/api/v1/shell/selfcheck/cancel": {
    /** Cancel running self-check */
    post: operations["shellSelfcheckCancel"];
  };
  "/api/v1/replay": {
    /** Start replay from log file */
    post: operations["replayStart"];
  };
  "/api/v1/replay/stop": {
    /** Stop running replay */
    post: operations["replayStop"];
  };
  "/api/v1/replay/status": {
    /** Get replay status */
    get: operations["replayStatus"];
  };
  "/api/v1/metrics/streams": {
    /** List all metric series */
    get: operations["listStreams"];
  };
  "/api/v1/metrics/query": {
    /** Query a specific metric series */
    get: operations["querySeries"];
  };
  "/events": {
    /**
     * WebSocket event stream
     * @description Upgrade to WebSocket for real-time event streaming
     */
    get: {
      responses: {
        /** @description Switching Protocols */
        101: {
          content: never;
        };
      };
    };
  };
  "/api/v1/autonomy/on": {
    /** Enable autonomy */
    post: operations["autonomyOn"];
  };
  "/api/v1/autonomy/off": {
    /** Disable autonomy */
    post: operations["autonomyOff"];
  };
  "/api/v1/autonomy/reset": {
    /** Reset autonomy state */
    post: operations["autonomyReset"];
  };
  "/api/v1/autonomy/interval": {
    /** Set autonomy interval */
    post: operations["autonomySetInterval"];
  };
  "/api/v1/autonomy/conf-threshold": {
    /** Set confidence threshold */
    post: operations["autonomySetThreshold"];
  };
  "/api/v1/autonomy/status": {
    /** Get autonomy status */
    get: operations["autonomyStatus"];
  };
  "/api/v1/autonomy/audit": {
    /** Get autonomy audit log */
    get: operations["autonomyAudit"];
  };
  "/api/v1/autonomy/explain": {
    /** Explain a decision */
    get: operations["autonomyExplain"];
  };
  "/api/v1/autonomy/preview": {
    /** Preview next decisions */
    post: operations["autonomyPreview"];
  };
  "/api/v1/autonomy/whatif": {
    /** What-if scenario analysis */
    post: operations["autonomyWhatIf"];
  };
  "/api/v1/mem/approvals": {
    /** Get pending approvals */
    get: operations["memGetApprovals"];
  };
  "/api/v1/mem/approval": {
    /** Toggle approval mode */
    post: operations["memApprovalToggle"];
  };
  "/api/v1/mem/approve": {
    /** Approve N operations */
    post: operations["memApprove"];
  };
  "/api/v1/mem/reject": {
    /** Reject operation(s) */
    post: operations["memReject"];
  };
  "/api/v1/graph/create": {
    /** Create a new graph */
    post: operations["graphCreate"];
  };
  "/api/v1/graph/add-channel": {
    /** Add a channel to a graph */
    post: operations["graphAddChannel"];
  };
  "/api/v1/graph/add-operator": {
    /** Add an operator to a graph */
    post: operations["graphAddOperator"];
  };
  "/api/v1/graph/start": {
    /** Start a graph execution */
    post: operations["graphStart"];
  };
  "/api/v1/graph/predict": {
    /** Predict operator performance */
    post: operations["graphPredict"];
  };
  "/api/v1/graph/feedback": {
    /** Submit feedback for operator */
    post: operations["graphFeedback"];
  };
  "/api/v1/graph/state": {
    /** Get graph state */
    get: operations["graphState"];
  };
  "/api/v1/graph/export": {
    /** Export graph as JSON */
    post: operations["graphExport"];
  };
  "/api/v1/sched/workloads": {
    /** Get list of workloads */
    get: operations["schedWorkloads"];
  };
  "/api/v1/sched/priorities": {
    /** Set workload priority */
    post: operations["schedSetPriority"];
  };
  "/api/v1/sched/affinity": {
    /** Set workload CPU affinity */
    post: operations["schedSetAffinity"];
  };
  "/api/v1/sched/feature": {
    /** Toggle scheduling feature */
    post: operations["schedSetFeature"];
  };
  "/api/v1/sched/circuit-breaker": {
    /** Get circuit breaker state */
    get: operations["schedCircuitBreakerStatus"];
  };
  "/api/v1/sched/circuit-breaker/reset": {
    /** Reset circuit breaker */
    post: operations["schedCircuitBreakerReset"];
  };
  "/api/v1/llm/load": {
    /** Load LLM model */
    post: operations["llmLoad"];
  };
  "/api/v1/llm/infer": {
    /** Submit inference request */
    post: operations["llmInfer"];
  };
  "/api/v1/llm/audit": {
    /** Get inference audit log */
    get: operations["llmAudit"];
  };
  "/api/v1/llm/status": {
    /** Get LLM status */
    get: operations["llmStatus"];
  };
  "/api/v1/logs/tail": {
    /** Tail logs with optional filters */
    get: operations["logsTail"];
  };
  "/api/v1/runs/start": {
    /** Start a new run */
    post: operations["runsStart"];
  };
  "/api/v1/runs/stop": {
    /** Stop current run */
    post: operations["runsStop"];
  };
  "/api/v1/runs/list": {
    /** List run history */
    get: operations["runsList"];
  };
  "/api/v1/runs/{runId}/export": {
    /** Export run logs and metrics */
    get: operations["runsExport"];
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: {
    HealthResponse: {
      /** @example ok */
      status: string;
      /** @example 0.1.0 */
      version: string;
      /** @example 3600 */
      uptime_secs?: number;
    };
    DaemonConfig: {
      /** @description Prompt pattern regex for shell detection */
      promptPattern: string;
      /**
       * Format: int64
       * @description Maximum output bytes per command
       */
      maxOutputBytes: number;
      /**
       * Format: int64
       * @description Retry-After seconds for 409 Conflict responses
       */
      retryAfterSeconds: number;
      /**
       * Format: int64
       * @description High-resolution metrics retention in milliseconds
       */
      metricsHighResRetentionMs: number;
      /**
       * Format: int64
       * @description Downsampled metrics retention in milliseconds
       */
      metricsDownsampleRetentionMs: number;
      /** @description Maximum number of unique metric series */
      metricsCardinalityLimit: number;
      /** @description Path to QEMU run script */
      runScript: string;
      /** @description Default features to enable */
      defaultFeatures: string[];
    };
    QemuConfig: {
      features?: string[];
      env?: {
        [key: string]: string;
      };
      args?: string[];
      working_dir?: string;
    };
    QemuStatus: {
      state: components["schemas"]["QemuState"];
      /** Format: int32 */
      pid?: number | null;
      /** Format: int64 */
      uptime_secs?: number | null;
      features: string[];
      error?: string | null;
      /** Format: int64 */
      lines_processed: number;
      /** Format: int64 */
      events_emitted: number;
    };
    /** @enum {string} */
    QemuState: "idle" | "starting" | "running" | "stopping" | "failed";
    ShellCommandRequest: {
      command: string;
      /** Format: int64 */
      timeout_ms?: number | null;
    };
    ShellCommandResponse: {
      command: string;
      output: string[];
      success: boolean;
      error?: string | null;
      /** Format: int64 */
      execution_time_ms: number;
    };
    SelfCheckResponse: {
      tests: components["schemas"]["TestResultEntry"][];
      total: number;
      passed: number;
      failed: number;
      success: boolean;
      /** Format: int64 */
      execution_time_ms: number;
    };
    TestResultEntry: {
      name: string;
      passed: boolean;
      /** Format: int64 */
      timestamp: number;
    };
    ReplayRequest: {
      /**
       * @description Log source mode
       * @default sample
       * @enum {string}
       */
      mode?: "sample" | "upload";
      /** @description Sample name or file identifier */
      logSource?: string;
      /** @description Base64-encoded log file content (mode=upload only) */
      file?: string;
      /**
       * @description Replay speed
       * @default realtime
       * @enum {string}
       */
      speed?: "instant" | "fast" | "realtime";
      /**
       * @deprecated
       * @description DEPRECATED: Use logSource with mode=sample
       */
      sample?: string;
    };
    ReplayResponse: {
      message: string;
      lines_processed: number;
    };
    ReplayStatus: {
      state: components["schemas"]["ReplayState"];
      source?: string | null;
      mode?: string | null;
      /** @description Progress percentage */
      progress: number;
    };
    /** @enum {string} */
    ReplayState: "idle" | "running";
    /** @description A single metric data point */
    MetricPoint: {
      /**
       * Format: int64
       * @description Unix timestamp in milliseconds
       */
      ts: number;
      /**
       * Format: int64
       * @description Metric value
       */
      value: number;
    };
    /** @description Statistics for a metric series */
    SeriesStats: {
      /** @description Total number of points recorded */
      count: number;
      /**
       * Format: int64
       * @description Minimum value
       */
      min: number;
      /**
       * Format: int64
       * @description Maximum value
       */
      max: number;
      /**
       * Format: double
       * @description Mean (average) value
       */
      mean: number;
      /**
       * Format: int64
       * @description Most recent value
       */
      last_value: number;
    };
    /** @description Metadata for a metric series */
    SeriesMetadata: {
      /** @description Series name */
      name: string;
      /** @description Number of points in series */
      count: number;
      /**
       * Format: int64
       * @description Timestamp of most recent point (ms)
       */
      lastTs: number;
      stats: components["schemas"]["SeriesStats"];
    };
    /** @description Result of a metric query */
    QueryResult: {
      /** @description Series name */
      name: string;
      /** @description Data points */
      points: components["schemas"]["MetricPoint"][];
      /** @description Whether data was downsampled */
      downsampled: boolean;
      /**
       * Format: int64
       * @description Start timestamp (ms)
       */
      from: number;
      /**
       * Format: int64
       * @description End timestamp (ms)
       */
      to: number;
    };
    /** @description RFC 7807 problem+json error response */
    ErrorResponse: {
      /**
       * Format: uri
       * @description URI reference identifying the problem type
       * @example /errors/query-bad-range
       */
      type?: string;
      /** @description Short, human-readable summary */
      title: string;
      /** @description HTTP status code */
      status: number;
      /** @description Human-readable explanation */
      detail: string;
      /**
       * Format: uri
       * @description URI reference to specific occurrence
       */
      instance?: string | null;
      /** @description Error message (legacy field) */
      error: string;
    };
    SuccessResponse: {
      message: string;
    };
    AutonomyStatus: {
      enabled: boolean;
      safe_mode?: boolean;
      learning_frozen?: boolean;
      interval_ms: number;
      threshold: number;
      total_decisions: number;
      accepted?: number;
      deferred?: number;
      watchdog_low_reward?: number;
      watchdog_high_td_error?: number;
    };
    AutonomyDecision: {
      id: string;
      timestamp_us: number;
      action: string;
      confidence: number;
      /** Format: float */
      reward?: number;
      executed?: boolean;
    };
    AttentionWeight: {
      feature: string;
      /** Format: float */
      weight: number;
    };
    ExplainResponse: {
      decision_id: string;
      explanation: string;
      reasoning?: string;
      attention?: components["schemas"]["AttentionWeight"][];
      context?: Record<string, never>;
    };
    PreviewRequest: {
      count: number;
    };
    PreviewResponse: {
      decisions: components["schemas"]["AutonomyDecision"][];
      would_execute?: boolean;
      confidence?: number;
    };
    WhatIfRequest: {
      overrides: Record<string, never>;
    };
    WhatIfResponse: {
      scenario: components["schemas"]["PreviewResponse"];
      warnings?: string[];
    };
    MemoryApprovalStatus: {
      enabled: boolean;
      pending_count: number;
      total_approved?: number;
      total_rejected?: number;
    };
    PendingOperation: {
      id: string;
      operation_type: string;
      confidence?: number;
      risk_score?: string;
      reason?: string;
      timestamp_us?: number;
    };
    ApprovalToggleRequest: {
      /** @enum {string} */
      action: "on" | "off" | "status";
    };
    ApproveRequest: {
      n: number;
    };
    RejectRequest: {
      id?: string;
    };
    CreateGraphResponse: {
      graphId: string;
    };
    AddChannelRequest: {
      graphId: string;
      cap: number;
    };
    AddChannelResponse: {
      channelId: string;
    };
    AddOperatorRequest: {
      graphId: string;
      opId: string;
      in?: string;
      out?: string;
      prio?: number;
      stage?: string;
      inSchema?: string;
      outSchema?: string;
    };
    AddOperatorResponse: {
      operatorId: string;
    };
    StartGraphRequest: {
      graphId: string;
      steps: number;
    };
    StartGraphResponse: {
      started: boolean;
    };
    PredictRequest: {
      opId: string;
      latency_us: number;
      depth: number;
      prio?: number;
    };
    PredictResponse: {
      predicted?: number;
      conf?: number;
    };
    FeedbackRequest: {
      opId: string;
      verdict: string;
    };
    FeedbackResponse: {
      recorded: boolean;
    };
    GraphOperator: {
      id?: string;
      stage?: string;
      prio?: number;
      state?: string;
    };
    GraphChannel: {
      id?: string;
      cap?: number;
      depth?: number;
    };
    GraphStats: {
      operator_count?: number;
      channel_count?: number;
      total_executions?: number;
    };
    GraphState: {
      operators?: components["schemas"]["GraphOperator"][];
      channels?: components["schemas"]["GraphChannel"][];
      stats?: components["schemas"]["GraphStats"];
    };
    ExportGraphRequest: {
      graphId: string;
      format: string;
    };
    ExportGraphResponse: {
      json: string;
    };
    Workload: {
      pid?: number;
      name?: string;
      prio?: number;
      cpu?: number;
      state?: string;
    };
    SetPriorityRequest: {
      pid: number;
      prio: number;
    };
    SetAffinityRequest: {
      pid: number;
      cpuMask: string;
    };
    SetFeatureRequest: {
      name: string;
      enable: boolean;
    };
    SchedResponse: {
      ok: boolean;
    };
    CircuitBreakerState: {
      state?: string;
      consecutive_failures?: number;
      failure_threshold?: number;
      reset_timeout_us?: number;
    };
    LoadModelRequest: {
      modelId: string;
      wcetCycles?: number;
      ctx?: number;
      vocab?: number;
      quant?: string;
      hash?: string;
      sig?: string;
    };
    LoadModelResponse: {
      loaded: boolean;
    };
    InferRequest: {
      text: string;
      maxTokens?: number;
    };
    InferResponse: {
      requestId: string;
    };
    AuditEntry: {
      id?: string;
      modelId?: string;
      tokens?: number;
      done?: boolean;
      ts?: number;
    };
    LlmStatus: {
      budget?: number;
      wcetCycles?: number;
      periodNs?: number;
      maxTokensPerPeriod?: number;
      queueDepth?: number;
      lastInferUs?: number;
    };
    LogEntry: {
      ts?: number;
      level?: string;
      source?: string;
      msg?: string;
    };
    RunProfile: {
      features?: string[];
      bringup?: boolean;
    };
    StartRunRequest: {
      profile: components["schemas"]["RunProfile"];
      note?: string;
    };
    StartRunResponse: {
      runId: string;
    };
    StopRunResponse: {
      ok: boolean;
    };
    RunHistoryEntry: {
      runId?: string;
      profile?: components["schemas"]["RunProfile"];
      startedAt?: number;
      stoppedAt?: number;
      markers?: string[];
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type $defs = Record<string, never>;

export type external = Record<string, never>;

export interface operations {

  /** Health check */
  health: {
    responses: {
      /** @description Service is healthy */
      200: {
        content: {
          "application/json": components["schemas"]["HealthResponse"];
        };
      };
    };
  };
  /** Get daemon configuration */
  getConfig: {
    responses: {
      /** @description Configuration retrieved */
      200: {
        content: {
          "application/json": components["schemas"]["DaemonConfig"];
        };
      };
    };
  };
  /** Run QEMU with configuration */
  qemuRun: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["QemuConfig"];
      };
    };
    responses: {
      /** @description QEMU started successfully */
      200: {
        content: {
          "application/json": components["schemas"]["SuccessResponse"];
        };
      };
      /** @description Invalid configuration */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Failed to start QEMU */
      500: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /** Stop QEMU */
  qemuStop: {
    responses: {
      /** @description QEMU stopped successfully */
      200: {
        content: {
          "application/json": components["schemas"]["SuccessResponse"];
        };
      };
      /** @description Failed to stop QEMU */
      500: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /** Get QEMU status */
  qemuStatus: {
    responses: {
      /** @description QEMU status retrieved */
      200: {
        content: {
          "application/json": components["schemas"]["QemuStatus"];
        };
      };
    };
  };
  /** Execute a shell command */
  shellExec: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ShellCommandRequest"];
      };
    };
    responses: {
      /** @description Command executed successfully */
      200: {
        content: {
          "application/json": components["schemas"]["ShellCommandResponse"];
        };
      };
      /** @description Invalid request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description System busy */
      409: {
        headers: {
          /** @description Seconds to wait before retrying */
          "Retry-After"?: number;
        };
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Execution failed */
      500: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Shell not ready */
      503: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /** Run self-check tests */
  shellSelfcheck: {
    responses: {
      /** @description Self-check completed */
      200: {
        content: {
          "application/json": components["schemas"]["SelfCheckResponse"];
        };
      };
      /** @description System busy */
      409: {
        headers: {
          "Retry-After"?: number;
        };
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Self-check failed */
      500: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Shell not ready */
      503: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /** Cancel running self-check */
  shellSelfcheckCancel: {
    responses: {
      /** @description Self-check canceled */
      200: {
        content: {
          "application/json": components["schemas"]["SuccessResponse"];
        };
      };
      /** @description No self-check running */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Cancel failed */
      500: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /** Start replay from log file */
  replayStart: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ReplayRequest"];
      };
    };
    responses: {
      /** @description Replay started */
      200: {
        content: {
          "application/json": components["schemas"]["ReplayResponse"];
        };
      };
      /** @description Invalid request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Replay already running */
      409: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Replay failed */
      500: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /** Stop running replay */
  replayStop: {
    responses: {
      /** @description Replay stopped */
      200: {
        content: {
          "application/json": components["schemas"]["SuccessResponse"];
        };
      };
      /** @description No replay running */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /** Get replay status */
  replayStatus: {
    responses: {
      /** @description Replay status retrieved */
      200: {
        content: {
          "application/json": components["schemas"]["ReplayStatus"];
        };
      };
    };
  };
  /** List all metric series */
  listStreams: {
    parameters: {
      query?: {
        /** @description Filter by name prefix */
        prefix?: string;
      };
    };
    responses: {
      /** @description List of metric series */
      200: {
        content: {
          "application/json": components["schemas"]["SeriesMetadata"][];
        };
      };
    };
  };
  /** Query a specific metric series */
  querySeries: {
    parameters: {
      query: {
        /** @description Metric name */
        name: string;
        /** @description Start timestamp in milliseconds */
        from?: number;
        /** @description End timestamp in milliseconds */
        to?: number;
        /** @description Maximum number of points to return (100-5000, default 1000) */
        maxPoints?: number;
      };
    };
    responses: {
      /** @description Metric data points */
      200: {
        content: {
          "application/json": components["schemas"]["QueryResult"];
        };
      };
      /** @description Invalid query parameters */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Series not found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /** Enable autonomy */
  autonomyOn: {
    responses: {
      /** @description Autonomy enabled */
      200: {
        content: {
          "application/json": components["schemas"]["AutonomyStatus"];
        };
      };
    };
  };
  /** Disable autonomy */
  autonomyOff: {
    responses: {
      /** @description Autonomy disabled */
      200: {
        content: {
          "application/json": components["schemas"]["AutonomyStatus"];
        };
      };
    };
  };
  /** Reset autonomy state */
  autonomyReset: {
    responses: {
      /** @description Autonomy reset */
      200: {
        content: {
          "application/json": components["schemas"]["AutonomyStatus"];
        };
      };
    };
  };
  /** Set autonomy interval */
  autonomySetInterval: {
    requestBody: {
      content: {
        "application/json": {
          interval_ms: number;
        };
      };
    };
    responses: {
      /** @description Interval updated */
      200: {
        content: {
          "application/json": components["schemas"]["AutonomyStatus"];
        };
      };
    };
  };
  /** Set confidence threshold */
  autonomySetThreshold: {
    requestBody: {
      content: {
        "application/json": {
          threshold: number;
        };
      };
    };
    responses: {
      /** @description Threshold updated */
      200: {
        content: {
          "application/json": components["schemas"]["AutonomyStatus"];
        };
      };
    };
  };
  /** Get autonomy status */
  autonomyStatus: {
    responses: {
      /** @description Autonomy status */
      200: {
        content: {
          "application/json": components["schemas"]["AutonomyStatus"];
        };
      };
    };
  };
  /** Get autonomy audit log */
  autonomyAudit: {
    parameters: {
      query?: {
        last?: number;
      };
    };
    responses: {
      /** @description Audit entries */
      200: {
        content: {
          "application/json": components["schemas"]["AutonomyDecision"][];
        };
      };
    };
  };
  /** Explain a decision */
  autonomyExplain: {
    parameters: {
      query: {
        id: string;
      };
    };
    responses: {
      /** @description Decision explanation */
      200: {
        content: {
          "application/json": components["schemas"]["ExplainResponse"];
        };
      };
    };
  };
  /** Preview next decisions */
  autonomyPreview: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["PreviewRequest"];
      };
    };
    responses: {
      /** @description Preview results */
      200: {
        content: {
          "application/json": components["schemas"]["PreviewResponse"];
        };
      };
    };
  };
  /** What-if scenario analysis */
  autonomyWhatIf: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["WhatIfRequest"];
      };
    };
    responses: {
      /** @description What-if results */
      200: {
        content: {
          "application/json": components["schemas"]["WhatIfResponse"];
        };
      };
    };
  };
  /** Get pending approvals */
  memGetApprovals: {
    parameters: {
      query?: {
        limit?: number;
      };
    };
    responses: {
      /** @description Pending operations */
      200: {
        content: {
          "application/json": components["schemas"]["PendingOperation"][];
        };
      };
    };
  };
  /** Toggle approval mode */
  memApprovalToggle: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ApprovalToggleRequest"];
      };
    };
    responses: {
      /** @description Approval mode updated */
      200: {
        content: {
          "application/json": components["schemas"]["MemoryApprovalStatus"];
        };
      };
    };
  };
  /** Approve N operations */
  memApprove: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ApproveRequest"];
      };
    };
    responses: {
      /** @description Operations approved */
      200: {
        content: {
          "application/json": components["schemas"]["MemoryApprovalStatus"];
        };
      };
    };
  };
  /** Reject operation(s) */
  memReject: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["RejectRequest"];
      };
    };
    responses: {
      /** @description Operations rejected */
      200: {
        content: {
          "application/json": components["schemas"]["MemoryApprovalStatus"];
        };
      };
    };
  };
  /** Create a new graph */
  graphCreate: {
    responses: {
      /** @description Graph created */
      200: {
        content: {
          "application/json": components["schemas"]["CreateGraphResponse"];
        };
      };
    };
  };
  /** Add a channel to a graph */
  graphAddChannel: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["AddChannelRequest"];
      };
    };
    responses: {
      /** @description Channel added */
      200: {
        content: {
          "application/json": components["schemas"]["AddChannelResponse"];
        };
      };
    };
  };
  /** Add an operator to a graph */
  graphAddOperator: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["AddOperatorRequest"];
      };
    };
    responses: {
      /** @description Operator added */
      200: {
        content: {
          "application/json": components["schemas"]["AddOperatorResponse"];
        };
      };
    };
  };
  /** Start a graph execution */
  graphStart: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["StartGraphRequest"];
      };
    };
    responses: {
      /** @description Graph started */
      200: {
        content: {
          "application/json": components["schemas"]["StartGraphResponse"];
        };
      };
    };
  };
  /** Predict operator performance */
  graphPredict: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["PredictRequest"];
      };
    };
    responses: {
      /** @description Prediction result */
      200: {
        content: {
          "application/json": components["schemas"]["PredictResponse"];
        };
      };
    };
  };
  /** Submit feedback for operator */
  graphFeedback: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["FeedbackRequest"];
      };
    };
    responses: {
      /** @description Feedback recorded */
      200: {
        content: {
          "application/json": components["schemas"]["FeedbackResponse"];
        };
      };
    };
  };
  /** Get graph state */
  graphState: {
    parameters: {
      query: {
        graphId: string;
      };
    };
    responses: {
      /** @description Graph state */
      200: {
        content: {
          "application/json": components["schemas"]["GraphState"];
        };
      };
    };
  };
  /** Export graph as JSON */
  graphExport: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ExportGraphRequest"];
      };
    };
    responses: {
      /** @description Graph exported */
      200: {
        content: {
          "application/json": components["schemas"]["ExportGraphResponse"];
        };
      };
    };
  };
  /** Get list of workloads */
  schedWorkloads: {
    responses: {
      /** @description List of workloads */
      200: {
        content: {
          "application/json": components["schemas"]["Workload"][];
        };
      };
    };
  };
  /** Set workload priority */
  schedSetPriority: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["SetPriorityRequest"];
      };
    };
    responses: {
      /** @description Priority updated */
      200: {
        content: {
          "application/json": components["schemas"]["SchedResponse"];
        };
      };
    };
  };
  /** Set workload CPU affinity */
  schedSetAffinity: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["SetAffinityRequest"];
      };
    };
    responses: {
      /** @description Affinity updated */
      200: {
        content: {
          "application/json": components["schemas"]["SchedResponse"];
        };
      };
    };
  };
  /** Toggle scheduling feature */
  schedSetFeature: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["SetFeatureRequest"];
      };
    };
    responses: {
      /** @description Feature toggled */
      200: {
        content: {
          "application/json": components["schemas"]["SchedResponse"];
        };
      };
    };
  };
  /** Get circuit breaker state */
  schedCircuitBreakerStatus: {
    responses: {
      /** @description Circuit breaker state */
      200: {
        content: {
          "application/json": components["schemas"]["CircuitBreakerState"];
        };
      };
    };
  };
  /** Reset circuit breaker */
  schedCircuitBreakerReset: {
    responses: {
      /** @description Circuit breaker reset */
      200: {
        content: {
          "application/json": components["schemas"]["SchedResponse"];
        };
      };
    };
  };
  /** Load LLM model */
  llmLoad: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["LoadModelRequest"];
      };
    };
    responses: {
      /** @description Model loaded */
      200: {
        content: {
          "application/json": components["schemas"]["LoadModelResponse"];
        };
      };
    };
  };
  /** Submit inference request */
  llmInfer: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["InferRequest"];
      };
    };
    responses: {
      /** @description Inference started */
      200: {
        content: {
          "application/json": components["schemas"]["InferResponse"];
        };
      };
    };
  };
  /** Get inference audit log */
  llmAudit: {
    responses: {
      /** @description Audit log entries */
      200: {
        content: {
          "application/json": components["schemas"]["AuditEntry"][];
        };
      };
    };
  };
  /** Get LLM status */
  llmStatus: {
    responses: {
      /** @description LLM status */
      200: {
        content: {
          "application/json": components["schemas"]["LlmStatus"];
        };
      };
    };
  };
  /** Tail logs with optional filters */
  logsTail: {
    parameters: {
      query?: {
        limit?: number;
        level?: string;
        source?: string;
      };
    };
    responses: {
      /** @description Log entries */
      200: {
        content: {
          "application/json": components["schemas"]["LogEntry"][];
        };
      };
    };
  };
  /** Start a new run */
  runsStart: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["StartRunRequest"];
      };
    };
    responses: {
      /** @description Run started */
      200: {
        content: {
          "application/json": components["schemas"]["StartRunResponse"];
        };
      };
    };
  };
  /** Stop current run */
  runsStop: {
    responses: {
      /** @description Run stopped */
      200: {
        content: {
          "application/json": components["schemas"]["StopRunResponse"];
        };
      };
    };
  };
  /** List run history */
  runsList: {
    responses: {
      /** @description Run history */
      200: {
        content: {
          "application/json": components["schemas"]["RunHistoryEntry"][];
        };
      };
    };
  };
  /** Export run logs and metrics */
  runsExport: {
    parameters: {
      path: {
        runId: string;
      };
    };
    responses: {
      /** @description Run snapshot exported */
      200: {
        content: {
          "application/json": unknown;
        };
      };
    };
  };
}
