/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */


export interface paths {
  "/health": {
    /** Health check */
    get: operations["health"];
  };
  "/api/v1/config": {
    /** Get daemon configuration */
    get: operations["getConfig"];
  };
  "/api/v1/qemu/run": {
    /** Run QEMU with configuration */
    post: operations["qemuRun"];
  };
  "/api/v1/qemu/stop": {
    /** Stop QEMU */
    post: operations["qemuStop"];
  };
  "/api/v1/qemu/status": {
    /** Get QEMU status */
    get: operations["qemuStatus"];
  };
  "/api/v1/shell/exec": {
    /** Execute a shell command */
    post: operations["shellExec"];
  };
  "/api/v1/shell/selfcheck": {
    /** Run self-check tests */
    post: operations["shellSelfcheck"];
  };
  "/api/v1/shell/selfcheck/cancel": {
    /** Cancel running self-check */
    post: operations["shellSelfcheckCancel"];
  };
  "/api/v1/replay": {
    /** Start replay from log file */
    post: operations["replayStart"];
  };
  "/api/v1/replay/stop": {
    /** Stop running replay */
    post: operations["replayStop"];
  };
  "/api/v1/replay/status": {
    /** Get replay status */
    get: operations["replayStatus"];
  };
  "/api/v1/metrics/streams": {
    /** List all metric series */
    get: operations["listStreams"];
  };
  "/api/v1/metrics/query": {
    /** Query a specific metric series */
    get: operations["querySeries"];
  };
  "/events": {
    /**
     * WebSocket event stream
     * @description Upgrade to WebSocket for real-time event streaming
     */
    get: {
      responses: {
        /** @description Switching Protocols */
        101: {
          content: never;
        };
      };
    };
  };
  "/api/v1/autonomy/on": {
    /** Enable autonomy */
    post: operations["autonomyOn"];
  };
  "/api/v1/autonomy/off": {
    /** Disable autonomy */
    post: operations["autonomyOff"];
  };
  "/api/v1/autonomy/reset": {
    /** Reset autonomy state */
    post: operations["autonomyReset"];
  };
  "/api/v1/autonomy/interval": {
    /** Set autonomy interval */
    post: operations["autonomySetInterval"];
  };
  "/api/v1/autonomy/conf-threshold": {
    /** Set confidence threshold */
    post: operations["autonomySetThreshold"];
  };
  "/api/v1/autonomy/status": {
    /** Get autonomy status */
    get: operations["autonomyStatus"];
  };
  "/api/v1/autonomy/audit": {
    /** Get autonomy audit log */
    get: operations["autonomyAudit"];
  };
  "/api/v1/autonomy/explain": {
    /** Explain a decision */
    get: operations["autonomyExplain"];
  };
  "/api/v1/autonomy/preview": {
    /** Preview next decisions */
    post: operations["autonomyPreview"];
  };
  "/api/v1/autonomy/whatif": {
    /** What-if scenario analysis */
    post: operations["autonomyWhatIf"];
  };
  "/api/v1/mem/approvals": {
    /** Get pending approvals */
    get: operations["memGetApprovals"];
  };
  "/api/v1/mem/approval": {
    /** Toggle approval mode */
    post: operations["memApprovalToggle"];
  };
  "/api/v1/mem/approve": {
    /** Approve N operations */
    post: operations["memApprove"];
  };
  "/api/v1/mem/reject": {
    /** Reject operation(s) */
    post: operations["memReject"];
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: {
    HealthResponse: {
      /** @example ok */
      status: string;
      /** @example 0.1.0 */
      version: string;
      /** @example 3600 */
      uptime_secs?: number;
    };
    DaemonConfig: {
      /** @description Prompt pattern regex for shell detection */
      promptPattern: string;
      /**
       * Format: int64
       * @description Maximum output bytes per command
       */
      maxOutputBytes: number;
      /**
       * Format: int64
       * @description Retry-After seconds for 409 Conflict responses
       */
      retryAfterSeconds: number;
      /**
       * Format: int64
       * @description High-resolution metrics retention in milliseconds
       */
      metricsHighResRetentionMs: number;
      /**
       * Format: int64
       * @description Downsampled metrics retention in milliseconds
       */
      metricsDownsampleRetentionMs: number;
      /** @description Maximum number of unique metric series */
      metricsCardinalityLimit: number;
      /** @description Path to QEMU run script */
      runScript: string;
      /** @description Default features to enable */
      defaultFeatures: string[];
    };
    QemuConfig: {
      features?: string[];
      env?: {
        [key: string]: string;
      };
      args?: string[];
      working_dir?: string;
    };
    QemuStatus: {
      state: components["schemas"]["QemuState"];
      /** Format: int32 */
      pid?: number | null;
      /** Format: int64 */
      uptime_secs?: number | null;
      features: string[];
      error?: string | null;
      /** Format: int64 */
      lines_processed: number;
      /** Format: int64 */
      events_emitted: number;
    };
    /** @enum {string} */
    QemuState: "idle" | "starting" | "running" | "stopping" | "failed";
    ShellCommandRequest: {
      command: string;
      /** Format: int64 */
      timeout_ms?: number | null;
    };
    ShellCommandResponse: {
      command: string;
      output: string[];
      success: boolean;
      error?: string | null;
      /** Format: int64 */
      execution_time_ms: number;
    };
    SelfCheckResponse: {
      tests: components["schemas"]["TestResultEntry"][];
      total: number;
      passed: number;
      failed: number;
      success: boolean;
      /** Format: int64 */
      execution_time_ms: number;
    };
    TestResultEntry: {
      name: string;
      passed: boolean;
      /** Format: int64 */
      timestamp: number;
    };
    ReplayRequest: {
      /**
       * @description Log source mode
       * @default sample
       * @enum {string}
       */
      mode?: "sample" | "upload";
      /** @description Sample name or file identifier */
      logSource?: string;
      /** @description Base64-encoded log file content (mode=upload only) */
      file?: string;
      /**
       * @description Replay speed
       * @default realtime
       * @enum {string}
       */
      speed?: "instant" | "fast" | "realtime";
      /**
       * @deprecated
       * @description DEPRECATED: Use logSource with mode=sample
       */
      sample?: string;
    };
    ReplayResponse: {
      message: string;
      lines_processed: number;
    };
    ReplayStatus: {
      state: components["schemas"]["ReplayState"];
      source?: string | null;
      mode?: string | null;
      /** @description Progress percentage */
      progress: number;
    };
    /** @enum {string} */
    ReplayState: "idle" | "running";
    /** @description A single metric data point */
    MetricPoint: {
      /**
       * Format: int64
       * @description Unix timestamp in milliseconds
       */
      ts: number;
      /**
       * Format: int64
       * @description Metric value
       */
      value: number;
    };
    /** @description Statistics for a metric series */
    SeriesStats: {
      /** @description Total number of points recorded */
      count: number;
      /**
       * Format: int64
       * @description Minimum value
       */
      min: number;
      /**
       * Format: int64
       * @description Maximum value
       */
      max: number;
      /**
       * Format: double
       * @description Mean (average) value
       */
      mean: number;
      /**
       * Format: int64
       * @description Most recent value
       */
      last_value: number;
    };
    /** @description Metadata for a metric series */
    SeriesMetadata: {
      /** @description Series name */
      name: string;
      /** @description Number of points in series */
      count: number;
      /**
       * Format: int64
       * @description Timestamp of most recent point (ms)
       */
      lastTs: number;
      stats: components["schemas"]["SeriesStats"];
    };
    /** @description Result of a metric query */
    QueryResult: {
      /** @description Series name */
      name: string;
      /** @description Data points */
      points: components["schemas"]["MetricPoint"][];
      /** @description Whether data was downsampled */
      downsampled: boolean;
      /**
       * Format: int64
       * @description Start timestamp (ms)
       */
      from: number;
      /**
       * Format: int64
       * @description End timestamp (ms)
       */
      to: number;
    };
    /** @description RFC 7807 problem+json error response */
    ErrorResponse: {
      /**
       * Format: uri
       * @description URI reference identifying the problem type
       * @example /errors/query-bad-range
       */
      type?: string;
      /** @description Short, human-readable summary */
      title: string;
      /** @description HTTP status code */
      status: number;
      /** @description Human-readable explanation */
      detail: string;
      /**
       * Format: uri
       * @description URI reference to specific occurrence
       */
      instance?: string | null;
      /** @description Error message (legacy field) */
      error: string;
    };
    SuccessResponse: {
      message: string;
    };
    AutonomyStatus: {
      enabled: boolean;
      safe_mode?: boolean;
      learning_frozen?: boolean;
      interval_ms: number;
      threshold: number;
      total_decisions: number;
      accepted?: number;
      deferred?: number;
      watchdog_low_reward?: number;
      watchdog_high_td_error?: number;
    };
    AutonomyDecision: {
      id: string;
      timestamp_us: number;
      action: string;
      confidence: number;
      /** Format: float */
      reward?: number;
      executed?: boolean;
    };
    AttentionWeight: {
      feature: string;
      /** Format: float */
      weight: number;
    };
    ExplainResponse: {
      decision_id: string;
      explanation: string;
      reasoning?: string;
      attention?: components["schemas"]["AttentionWeight"][];
      context?: Record<string, never>;
    };
    PreviewRequest: {
      count: number;
    };
    PreviewResponse: {
      decisions: components["schemas"]["AutonomyDecision"][];
      would_execute?: boolean;
      confidence?: number;
    };
    WhatIfRequest: {
      overrides: Record<string, never>;
    };
    WhatIfResponse: {
      scenario: components["schemas"]["PreviewResponse"];
      warnings?: string[];
    };
    MemoryApprovalStatus: {
      enabled: boolean;
      pending_count: number;
      total_approved?: number;
      total_rejected?: number;
    };
    PendingOperation: {
      id: string;
      operation_type: string;
      confidence?: number;
      risk_score?: string;
      reason?: string;
      timestamp_us?: number;
    };
    ApprovalToggleRequest: {
      /** @enum {string} */
      action: "on" | "off" | "status";
    };
    ApproveRequest: {
      n: number;
    };
    RejectRequest: {
      id?: string;
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type $defs = Record<string, never>;

export type external = Record<string, never>;

export interface operations {

  /** Health check */
  health: {
    responses: {
      /** @description Service is healthy */
      200: {
        content: {
          "application/json": components["schemas"]["HealthResponse"];
        };
      };
    };
  };
  /** Get daemon configuration */
  getConfig: {
    responses: {
      /** @description Configuration retrieved */
      200: {
        content: {
          "application/json": components["schemas"]["DaemonConfig"];
        };
      };
    };
  };
  /** Run QEMU with configuration */
  qemuRun: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["QemuConfig"];
      };
    };
    responses: {
      /** @description QEMU started successfully */
      200: {
        content: {
          "application/json": components["schemas"]["SuccessResponse"];
        };
      };
      /** @description Invalid configuration */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Failed to start QEMU */
      500: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /** Stop QEMU */
  qemuStop: {
    responses: {
      /** @description QEMU stopped successfully */
      200: {
        content: {
          "application/json": components["schemas"]["SuccessResponse"];
        };
      };
      /** @description Failed to stop QEMU */
      500: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /** Get QEMU status */
  qemuStatus: {
    responses: {
      /** @description QEMU status retrieved */
      200: {
        content: {
          "application/json": components["schemas"]["QemuStatus"];
        };
      };
    };
  };
  /** Execute a shell command */
  shellExec: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ShellCommandRequest"];
      };
    };
    responses: {
      /** @description Command executed successfully */
      200: {
        content: {
          "application/json": components["schemas"]["ShellCommandResponse"];
        };
      };
      /** @description Invalid request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description System busy */
      409: {
        headers: {
          /** @description Seconds to wait before retrying */
          "Retry-After"?: number;
        };
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Execution failed */
      500: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Shell not ready */
      503: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /** Run self-check tests */
  shellSelfcheck: {
    responses: {
      /** @description Self-check completed */
      200: {
        content: {
          "application/json": components["schemas"]["SelfCheckResponse"];
        };
      };
      /** @description System busy */
      409: {
        headers: {
          "Retry-After"?: number;
        };
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Self-check failed */
      500: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Shell not ready */
      503: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /** Cancel running self-check */
  shellSelfcheckCancel: {
    responses: {
      /** @description Self-check canceled */
      200: {
        content: {
          "application/json": components["schemas"]["SuccessResponse"];
        };
      };
      /** @description No self-check running */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Cancel failed */
      500: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /** Start replay from log file */
  replayStart: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ReplayRequest"];
      };
    };
    responses: {
      /** @description Replay started */
      200: {
        content: {
          "application/json": components["schemas"]["ReplayResponse"];
        };
      };
      /** @description Invalid request */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Replay already running */
      409: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Replay failed */
      500: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /** Stop running replay */
  replayStop: {
    responses: {
      /** @description Replay stopped */
      200: {
        content: {
          "application/json": components["schemas"]["SuccessResponse"];
        };
      };
      /** @description No replay running */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /** Get replay status */
  replayStatus: {
    responses: {
      /** @description Replay status retrieved */
      200: {
        content: {
          "application/json": components["schemas"]["ReplayStatus"];
        };
      };
    };
  };
  /** List all metric series */
  listStreams: {
    parameters: {
      query?: {
        /** @description Filter by name prefix */
        prefix?: string;
      };
    };
    responses: {
      /** @description List of metric series */
      200: {
        content: {
          "application/json": components["schemas"]["SeriesMetadata"][];
        };
      };
    };
  };
  /** Query a specific metric series */
  querySeries: {
    parameters: {
      query: {
        /** @description Metric name */
        name: string;
        /** @description Start timestamp in milliseconds */
        from?: number;
        /** @description End timestamp in milliseconds */
        to?: number;
        /** @description Maximum number of points to return (100-5000, default 1000) */
        maxPoints?: number;
      };
    };
    responses: {
      /** @description Metric data points */
      200: {
        content: {
          "application/json": components["schemas"]["QueryResult"];
        };
      };
      /** @description Invalid query parameters */
      400: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
      /** @description Series not found */
      404: {
        content: {
          "application/json": components["schemas"]["ErrorResponse"];
        };
      };
    };
  };
  /** Enable autonomy */
  autonomyOn: {
    responses: {
      /** @description Autonomy enabled */
      200: {
        content: {
          "application/json": components["schemas"]["AutonomyStatus"];
        };
      };
    };
  };
  /** Disable autonomy */
  autonomyOff: {
    responses: {
      /** @description Autonomy disabled */
      200: {
        content: {
          "application/json": components["schemas"]["AutonomyStatus"];
        };
      };
    };
  };
  /** Reset autonomy state */
  autonomyReset: {
    responses: {
      /** @description Autonomy reset */
      200: {
        content: {
          "application/json": components["schemas"]["AutonomyStatus"];
        };
      };
    };
  };
  /** Set autonomy interval */
  autonomySetInterval: {
    requestBody: {
      content: {
        "application/json": {
          interval_ms: number;
        };
      };
    };
    responses: {
      /** @description Interval updated */
      200: {
        content: {
          "application/json": components["schemas"]["AutonomyStatus"];
        };
      };
    };
  };
  /** Set confidence threshold */
  autonomySetThreshold: {
    requestBody: {
      content: {
        "application/json": {
          threshold: number;
        };
      };
    };
    responses: {
      /** @description Threshold updated */
      200: {
        content: {
          "application/json": components["schemas"]["AutonomyStatus"];
        };
      };
    };
  };
  /** Get autonomy status */
  autonomyStatus: {
    responses: {
      /** @description Autonomy status */
      200: {
        content: {
          "application/json": components["schemas"]["AutonomyStatus"];
        };
      };
    };
  };
  /** Get autonomy audit log */
  autonomyAudit: {
    parameters: {
      query?: {
        last?: number;
      };
    };
    responses: {
      /** @description Audit entries */
      200: {
        content: {
          "application/json": components["schemas"]["AutonomyDecision"][];
        };
      };
    };
  };
  /** Explain a decision */
  autonomyExplain: {
    parameters: {
      query: {
        id: string;
      };
    };
    responses: {
      /** @description Decision explanation */
      200: {
        content: {
          "application/json": components["schemas"]["ExplainResponse"];
        };
      };
    };
  };
  /** Preview next decisions */
  autonomyPreview: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["PreviewRequest"];
      };
    };
    responses: {
      /** @description Preview results */
      200: {
        content: {
          "application/json": components["schemas"]["PreviewResponse"];
        };
      };
    };
  };
  /** What-if scenario analysis */
  autonomyWhatIf: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["WhatIfRequest"];
      };
    };
    responses: {
      /** @description What-if results */
      200: {
        content: {
          "application/json": components["schemas"]["WhatIfResponse"];
        };
      };
    };
  };
  /** Get pending approvals */
  memGetApprovals: {
    parameters: {
      query?: {
        limit?: number;
      };
    };
    responses: {
      /** @description Pending operations */
      200: {
        content: {
          "application/json": components["schemas"]["PendingOperation"][];
        };
      };
    };
  };
  /** Toggle approval mode */
  memApprovalToggle: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ApprovalToggleRequest"];
      };
    };
    responses: {
      /** @description Approval mode updated */
      200: {
        content: {
          "application/json": components["schemas"]["MemoryApprovalStatus"];
        };
      };
    };
  };
  /** Approve N operations */
  memApprove: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["ApproveRequest"];
      };
    };
    responses: {
      /** @description Operations approved */
      200: {
        content: {
          "application/json": components["schemas"]["MemoryApprovalStatus"];
        };
      };
    };
  };
  /** Reject operation(s) */
  memReject: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["RejectRequest"];
      };
    };
    responses: {
      /** @description Operations rejected */
      200: {
        content: {
          "application/json": components["schemas"]["MemoryApprovalStatus"];
        };
      };
    };
  };
}
