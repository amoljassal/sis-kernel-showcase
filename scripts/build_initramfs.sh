#!/bin/bash
# Build script for Phase A1 initramfs with static BusyBox
#
# Creates a minimal root filesystem with BusyBox and packs it into
# an uncompressed cpio newc archive for embedding in the kernel.

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
ROOT_DIR="$SCRIPT_DIR/.."
BUILD_DIR="$ROOT_DIR/build"
ROOTFS_DIR="$BUILD_DIR/rootfs"
BUSYBOX_VERSION="1.36.1"
BUSYBOX_URL="https://busybox.net/downloads/busybox-${BUSYBOX_VERSION}.tar.bz2"

echo "==> Phase A1: Building initramfs with BusyBox"

# Create build directory
mkdir -p "$BUILD_DIR"
cd "$BUILD_DIR"

# Download and extract BusyBox if not already present
if [ ! -d "busybox-${BUSYBOX_VERSION}" ]; then
    echo "==> Downloading BusyBox ${BUSYBOX_VERSION}"
    if [ ! -f "busybox-${BUSYBOX_VERSION}.tar.bz2" ]; then
        wget "$BUSYBOX_URL" || curl -L -O "$BUSYBOX_URL"
    fi
    echo "==> Extracting BusyBox"
    tar xjf "busybox-${BUSYBOX_VERSION}.tar.bz2"
fi

cd "busybox-${BUSYBOX_VERSION}"

# Configure BusyBox for static build with musl
echo "==> Configuring BusyBox (static musl build)"
if [ ! -f .config ]; then
    make defconfig
    # Enable static linking
    sed -i 's/# CONFIG_STATIC is not set/CONFIG_STATIC=y/' .config
    # Disable features that require advanced kernel support
    sed -i 's/CONFIG_FEATURE_PREFER_APPLETS=y/# CONFIG_FEATURE_PREFER_APPLETS is not set/' .config || true
fi

# Build BusyBox
echo "==> Building BusyBox (this may take a few minutes)"
make -j$(nproc) CC="${CC:-gcc}" 2>&1 | grep -v "warning:" || true

if [ ! -f busybox ]; then
    echo "ERROR: BusyBox build failed"
    exit 1
fi

echo "==> BusyBox built successfully: $(file busybox)"

# Create root filesystem structure
echo "==> Creating root filesystem"
cd "$BUILD_DIR"
rm -rf "$ROOTFS_DIR"
mkdir -p "$ROOTFS_DIR"/{bin,sbin,dev,proc,sys,tmp,etc}

# Copy BusyBox binary
cp "busybox-${BUSYBOX_VERSION}/busybox" "$ROOTFS_DIR/bin/"
chmod 755 "$ROOTFS_DIR/bin/busybox"

# Create symlinks for common commands
cd "$ROOTFS_DIR/bin"
for cmd in sh ash ls cat echo pwd mkdir rmdir rm cp mv touch chmod chown ln mount umount ps kill; do
    ln -sf busybox "$cmd"
done
cd "$BUILD_DIR"

# Create /sbin/init script
cat > "$ROOTFS_DIR/sbin/init" << 'EOF'
#!/bin/sh
# Phase A1 init script

echo "SIS Kernel Phase A1 - Init starting"

# Mount pseudo-filesystems (if mount syscall is available)
# For Phase A1, devfs is already mounted by kernel
# mount -t proc none /proc 2>/dev/null || echo "proc mount skipped"
# mount -t sysfs none /sys 2>/dev/null || echo "sysfs mount skipped"

echo "Init complete - starting shell"

# Start interactive shell
exec /bin/sh
EOF

chmod 755 "$ROOTFS_DIR/sbin/init"

# Create basic /etc files
cat > "$ROOTFS_DIR/etc/passwd" << 'EOF'
root:x:0:0:root:/root:/bin/sh
EOF

cat > "$ROOTFS_DIR/etc/group" << 'EOF'
root:x:0:
EOF

# Set permissions
chmod 755 "$ROOTFS_DIR"/{bin,sbin,dev,proc,sys,tmp,etc}
chmod 1777 "$ROOTFS_DIR/tmp"

# Create cpio archive (newc format, uncompressed)
echo "==> Creating cpio archive"
cd "$ROOTFS_DIR"
find . -print0 | cpio --null -o -H newc > "$BUILD_DIR/initramfs.cpio"
cd "$BUILD_DIR"

echo "==> initramfs.cpio created ($(du -h initramfs.cpio | cut -f1))"
ls -lh initramfs.cpio

# Verify archive
echo "==> Verifying archive contents"
cpio -t < initramfs.cpio | head -20

# For kernel embedding, we need this as a Rust byte array
echo "==> Creating Rust include file"
cat > "$ROOT_DIR/crates/kernel/initramfs_data.rs" << 'RUST_EOF'
// Auto-generated initramfs data
// Generated by scripts/build_initramfs.sh

pub const INITRAMFS_DATA: &[u8] = include_bytes!(concat!(env!("CARGO_MANIFEST_DIR"), "/../../build/initramfs.cpio"));
RUST_EOF

echo ""
echo "==> Build complete!"
echo "    initramfs.cpio: $BUILD_DIR/initramfs.cpio"
echo "    Root filesystem: $ROOTFS_DIR"
echo ""
echo "To test manually:"
echo "  cpio -idmv < $BUILD_DIR/initramfs.cpio"
echo ""
echo "To use in kernel:"
echo "  1. Rebuild kernel (initramfs_data.rs included automatically)"
echo "  2. Boot with QEMU"
