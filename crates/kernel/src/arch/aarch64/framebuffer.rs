//! Simple framebuffer driver for AArch64
//! Writes text directly to the framebuffer passed from UEFI

use core::sync::atomic::{AtomicUsize, Ordering};
use spin::Mutex;

/// Boot info passed from UEFI bootloader
#[repr(C)]
#[derive(Clone, Copy, Default)]
pub struct BootInfo {
    pub rsdp_addr: u64,
    pub framebuffer_addr: u64,
    pub framebuffer_width: u32,
    pub framebuffer_height: u32,
    pub framebuffer_pitch: u32,
    pub framebuffer_bpp: u32,
}

/// Global framebuffer state
static FRAMEBUFFER: Mutex<Option<Framebuffer>> = Mutex::new(None);

/// Simple 8x8 font for text rendering
struct Framebuffer {
    addr: u64,
    width: u32,
    height: u32,
    pitch: u32,
    x: u32,
    y: u32,
}

impl Framebuffer {
    fn new(info: &BootInfo) -> Option<Self> {
        if info.framebuffer_addr == 0 || info.framebuffer_width == 0 {
            return None;
        }

        Some(Self {
            addr: info.framebuffer_addr,
            width: info.framebuffer_width,
            height: info.framebuffer_height,
            pitch: info.framebuffer_pitch,
            x: 0,
            y: 0,
        })
    }

    /// Write a single pixel
    fn put_pixel(&self, x: u32, y: u32, color: u32) {
        if x >= self.width || y >= self.height {
            return;
        }

        let offset = (y * self.pitch / 4 + x) as usize;
        let ptr = (self.addr as usize + offset * 4) as *mut u32;
        unsafe {
            core::ptr::write_volatile(ptr, color);
        }
    }

    /// Draw a character at current position (simple 8x8 bitmap font)
    fn draw_char(&mut self, ch: u8, color: u32) {
        const FONT_WIDTH: u32 = 8;
        const FONT_HEIGHT: u32 = 8;

        let glyph = get_font_glyph(ch);

        for dy in 0..FONT_HEIGHT {
            for dx in 0..FONT_WIDTH {
                if (glyph[dy as usize] & (1 << (7 - dx))) != 0 {
                    self.put_pixel(self.x + dx, self.y + dy, color);
                }
            }
        }

        self.x += FONT_WIDTH;
        if self.x + FONT_WIDTH >= self.width {
            self.newline();
        }
    }

    fn newline(&mut self) {
        self.x = 0;
        self.y += 8;
        if self.y + 8 >= self.height {
            // Scroll: simple wrap for now
            self.y = 0;
            self.clear_screen();
        }
    }

    fn clear_screen(&self) {
        for y in 0..self.height {
            for x in 0..self.width {
                self.put_pixel(x, y, 0x000000); // Black
            }
        }
    }
}

/// Initialize framebuffer from BootInfo
pub fn init(boot_info: &BootInfo) {
    if let Some(fb) = Framebuffer::new(boot_info) {
        *FRAMEBUFFER.lock() = Some(fb);
    }
}

/// Write a byte to framebuffer
pub fn write_byte(byte: u8) {
    let mut fb_lock = FRAMEBUFFER.lock();
    if let Some(fb) = fb_lock.as_mut() {
        match byte {
            b'\n' => fb.newline(),
            b'\r' => fb.x = 0,
            ch if ch >= 0x20 && ch < 0x7f => fb.draw_char(ch, 0xFFFFFF), // White text
            _ => {}
        }
    }
}

/// Write bytes to framebuffer
pub fn write_bytes(bytes: &[u8]) {
    for &byte in bytes {
        write_byte(byte);
    }
}

/// Simple 8x8 bitmap font (ASCII 0x20-0x7E)
fn get_font_glyph(ch: u8) -> &'static [u8; 8] {
    const FONT_DATA: [[u8; 8]; 95] = [
        // Space (0x20)
        [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        // ! (0x21)
        [0x18, 0x3C, 0x3C, 0x18, 0x18, 0x00, 0x18, 0x00],
        // " (0x22)
        [0x36, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        // # (0x23)
        [0x36, 0x36, 0x7F, 0x36, 0x7F, 0x36, 0x36, 0x00],
        // $ (0x24)
        [0x0C, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x0C, 0x00],
        // % (0x25)
        [0x00, 0x63, 0x33, 0x18, 0x0C, 0x66, 0x63, 0x00],
        // & (0x26)
        [0x1C, 0x36, 0x1C, 0x6E, 0x3B, 0x33, 0x6E, 0x00],
        // ' (0x27)
        [0x06, 0x06, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00],
        // ( (0x28)
        [0x18, 0x0C, 0x06, 0x06, 0x06, 0x0C, 0x18, 0x00],
        // ) (0x29)
        [0x06, 0x0C, 0x18, 0x18, 0x18, 0x0C, 0x06, 0x00],
        // * (0x2A)
        [0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00],
        // + (0x2B)
        [0x00, 0x0C, 0x0C, 0x3F, 0x0C, 0x0C, 0x00, 0x00],
        // , (0x2C)
        [0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x06],
        // - (0x2D)
        [0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00],
        // . (0x2E)
        [0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x00],
        // / (0x2F)
        [0x60, 0x30, 0x18, 0x0C, 0x06, 0x03, 0x01, 0x00],
        // 0-9 and more characters...
        // For brevity, using simple patterns
        [0x3E, 0x63, 0x73, 0x7B, 0x6F, 0x67, 0x3E, 0x00], // 0
        [0x0C, 0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x3F, 0x00], // 1
        [0x1E, 0x33, 0x30, 0x1C, 0x06, 0x33, 0x3F, 0x00], // 2
        [0x1E, 0x33, 0x30, 0x1C, 0x30, 0x33, 0x1E, 0x00], // 3
        [0x38, 0x3C, 0x36, 0x33, 0x7F, 0x30, 0x78, 0x00], // 4
        [0x3F, 0x03, 0x1F, 0x30, 0x30, 0x33, 0x1E, 0x00], // 5
        [0x1C, 0x06, 0x03, 0x1F, 0x33, 0x33, 0x1E, 0x00], // 6
        [0x3F, 0x33, 0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x00], // 7
        [0x1E, 0x33, 0x33, 0x1E, 0x33, 0x33, 0x1E, 0x00], // 8
        [0x1E, 0x33, 0x33, 0x3E, 0x30, 0x18, 0x0E, 0x00], // 9
        // : ; < = > ? @ (0x3A-0x40)
        [0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x00], // :
        [0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x06], // ;
        [0x18, 0x0C, 0x06, 0x03, 0x06, 0x0C, 0x18, 0x00], // <
        [0x00, 0x00, 0x3F, 0x00, 0x00, 0x3F, 0x00, 0x00], // =
        [0x06, 0x0C, 0x18, 0x30, 0x18, 0x0C, 0x06, 0x00], // >
        [0x1E, 0x33, 0x30, 0x18, 0x0C, 0x00, 0x0C, 0x00], // ?
        [0x3E, 0x63, 0x7B, 0x7B, 0x7B, 0x03, 0x1E, 0x00], // @
        // A-Z (0x41-0x5A)
        [0x0C, 0x1E, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x00], // A
        [0x3F, 0x66, 0x66, 0x3E, 0x66, 0x66, 0x3F, 0x00], // B
        [0x3C, 0x66, 0x03, 0x03, 0x03, 0x66, 0x3C, 0x00], // C
        [0x1F, 0x36, 0x66, 0x66, 0x66, 0x36, 0x1F, 0x00], // D
        [0x7F, 0x46, 0x16, 0x1E, 0x16, 0x46, 0x7F, 0x00], // E
        [0x7F, 0x46, 0x16, 0x1E, 0x16, 0x06, 0x0F, 0x00], // F
        [0x3C, 0x66, 0x03, 0x03, 0x73, 0x66, 0x7C, 0x00], // G
        [0x33, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x33, 0x00], // H
        [0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00], // I
        [0x78, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E, 0x00], // J
        [0x67, 0x66, 0x36, 0x1E, 0x36, 0x66, 0x67, 0x00], // K
        [0x0F, 0x06, 0x06, 0x06, 0x46, 0x66, 0x7F, 0x00], // L
        [0x63, 0x77, 0x7F, 0x7F, 0x6B, 0x63, 0x63, 0x00], // M
        [0x63, 0x67, 0x6F, 0x7B, 0x73, 0x63, 0x63, 0x00], // N
        [0x1C, 0x36, 0x63, 0x63, 0x63, 0x36, 0x1C, 0x00], // O
        [0x3F, 0x66, 0x66, 0x3E, 0x06, 0x06, 0x0F, 0x00], // P
        [0x1E, 0x33, 0x33, 0x33, 0x3B, 0x1E, 0x38, 0x00], // Q
        [0x3F, 0x66, 0x66, 0x3E, 0x36, 0x66, 0x67, 0x00], // R
        [0x1E, 0x33, 0x07, 0x0E, 0x38, 0x33, 0x1E, 0x00], // S
        [0x3F, 0x2D, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00], // T
        [0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x3F, 0x00], // U
        [0x33, 0x33, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00], // V
        [0x63, 0x63, 0x63, 0x6B, 0x7F, 0x77, 0x63, 0x00], // W
        [0x63, 0x63, 0x36, 0x1C, 0x1C, 0x36, 0x63, 0x00], // X
        [0x33, 0x33, 0x33, 0x1E, 0x0C, 0x0C, 0x1E, 0x00], // Y
        [0x7F, 0x63, 0x31, 0x18, 0x4C, 0x66, 0x7F, 0x00], // Z
        // [ \ ] ^ _ ` (0x5B-0x60)
        [0x1E, 0x06, 0x06, 0x06, 0x06, 0x06, 0x1E, 0x00], // [
        [0x03, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x40, 0x00], // \
        [0x1E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1E, 0x00], // ]
        [0x08, 0x1C, 0x36, 0x63, 0x00, 0x00, 0x00, 0x00], // ^
        [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF], // _
        [0x0C, 0x0C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00], // `
        // a-z (0x61-0x7A) - using simplified lowercase = uppercase for now
        [0x00, 0x00, 0x1E, 0x30, 0x3E, 0x33, 0x6E, 0x00], // a
        [0x07, 0x06, 0x06, 0x3E, 0x66, 0x66, 0x3B, 0x00], // b
        [0x00, 0x00, 0x1E, 0x33, 0x03, 0x33, 0x1E, 0x00], // c
        [0x38, 0x30, 0x30, 0x3e, 0x33, 0x33, 0x6E, 0x00], // d
        [0x00, 0x00, 0x1E, 0x33, 0x3f, 0x03, 0x1E, 0x00], // e
        [0x1C, 0x36, 0x06, 0x0f, 0x06, 0x06, 0x0F, 0x00], // f
        [0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x1F], // g
        [0x07, 0x06, 0x36, 0x6E, 0x66, 0x66, 0x67, 0x00], // h
        [0x0C, 0x00, 0x0E, 0x0C, 0x0C, 0x0C, 0x1E, 0x00], // i
        [0x30, 0x00, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E], // j
        [0x07, 0x06, 0x66, 0x36, 0x1E, 0x36, 0x67, 0x00], // k
        [0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00], // l
        [0x00, 0x00, 0x33, 0x7F, 0x7F, 0x6B, 0x63, 0x00], // m
        [0x00, 0x00, 0x1F, 0x33, 0x33, 0x33, 0x33, 0x00], // n
        [0x00, 0x00, 0x1E, 0x33, 0x33, 0x33, 0x1E, 0x00], // o
        [0x00, 0x00, 0x3B, 0x66, 0x66, 0x3E, 0x06, 0x0F], // p
        [0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x78], // q
        [0x00, 0x00, 0x3B, 0x6E, 0x66, 0x06, 0x0F, 0x00], // r
        [0x00, 0x00, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x00], // s
        [0x08, 0x0C, 0x3E, 0x0C, 0x0C, 0x2C, 0x18, 0x00], // t
        [0x00, 0x00, 0x33, 0x33, 0x33, 0x33, 0x6E, 0x00], // u
        [0x00, 0x00, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00], // v
        [0x00, 0x00, 0x63, 0x6B, 0x7F, 0x7F, 0x36, 0x00], // w
        [0x00, 0x00, 0x63, 0x36, 0x1C, 0x36, 0x63, 0x00], // x
        [0x00, 0x00, 0x33, 0x33, 0x33, 0x3E, 0x30, 0x1F], // y
        [0x00, 0x00, 0x3F, 0x19, 0x0C, 0x26, 0x3F, 0x00], // z
        // { | } ~ (0x7B-0x7E)
        [0x38, 0x0C, 0x0C, 0x07, 0x0C, 0x0C, 0x38, 0x00], // {
        [0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00], // |
        [0x07, 0x0C, 0x0C, 0x38, 0x0C, 0x0C, 0x07, 0x00], // }
        [0x6E, 0x3B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // ~
    ];

    let idx = if ch >= 0x20 && ch < 0x7F {
        (ch - 0x20) as usize
    } else {
        0 // Default to space
    };

    &FONT_DATA[idx]
}
