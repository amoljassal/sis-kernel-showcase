// Build script for SIS Kernel
// Phase 5 - Production Readiness Plan
//
// Generates build metadata for forensics and debugging

use std::env;
use std::fs;
use std::path::Path;
use std::process::Command;

fn main() {
    println!("cargo:rerun-if-changed=build.rs");

    // Get git information
    let git_commit = get_git_commit();
    let git_branch = get_git_branch();
    let git_dirty = is_git_dirty();

    // Get build timestamp
    let build_timestamp = chrono::Utc::now().to_rfc3339();

    // Get Rust version
    let rust_version = get_rust_version();

    // Get enabled features
    let features = get_enabled_features();

    // Get build profile (debug/release)
    let profile = env::var("PROFILE").unwrap_or_else(|_| "unknown".to_string());

    // Get target triple
    let target = env::var("TARGET").unwrap_or_else(|_| "unknown".to_string());

    // Generate build info as JSON
    let build_info = format!(
        r#"{{
    "git_commit": "{}",
    "git_branch": "{}",
    "git_dirty": {},
    "build_timestamp": "{}",
    "rust_version": "{}",
    "features": "{}",
    "profile": "{}",
    "target": "{}"
}}"#,
        escape_json(&git_commit),
        escape_json(&git_branch),
        git_dirty,
        escape_json(&build_timestamp),
        escape_json(&rust_version),
        escape_json(&features),
        escape_json(&profile),
        escape_json(&target)
    );

    // Write to OUT_DIR
    let out_dir = env::var("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("build_info.json");
    fs::write(&dest_path, &build_info).expect("Failed to write build_info.json");

    // Also generate Rust source file
    let build_info_rs = format!(
        r#"// Auto-generated build information
// DO NOT EDIT - Generated by build.rs

pub const GIT_COMMIT: &str = "{}";
pub const GIT_BRANCH: &str = "{}";
pub const GIT_DIRTY: bool = {};
pub const BUILD_TIMESTAMP: &str = "{}";
pub const RUST_VERSION: &str = "{}";
pub const FEATURES: &str = "{}";
pub const PROFILE: &str = "{}";
pub const TARGET: &str = "{}";

pub const BUILD_INFO_JSON: &str = r#"{}"#;
"#,
        escape_rust(&git_commit),
        escape_rust(&git_branch),
        git_dirty,
        escape_rust(&build_timestamp),
        escape_rust(&rust_version),
        escape_rust(&features),
        escape_rust(&profile),
        escape_rust(&target),
        escape_rust(&build_info)
    );

    let build_info_rs_path = Path::new(&out_dir).join("build_info.rs");
    fs::write(&build_info_rs_path, &build_info_rs).expect("Failed to write build_info.rs");

    println!("cargo:rustc-env=GIT_COMMIT={}", git_commit);
    println!("cargo:rustc-env=GIT_BRANCH={}", git_branch);
    println!("cargo:rustc-env=BUILD_TIMESTAMP={}", build_timestamp);
}

fn get_git_commit() -> String {
    Command::new("git")
        .args(&["rev-parse", "HEAD"])
        .output()
        .ok()
        .and_then(|output| {
            if output.status.success() {
                String::from_utf8(output.stdout).ok()
            } else {
                None
            }
        })
        .map(|s| s.trim().to_string())
        .unwrap_or_else(|| "unknown".to_string())
}

fn get_git_branch() -> String {
    Command::new("git")
        .args(&["branch", "--show-current"])
        .output()
        .ok()
        .and_then(|output| {
            if output.status.success() {
                String::from_utf8(output.stdout).ok()
            } else {
                None
            }
        })
        .map(|s| s.trim().to_string())
        .unwrap_or_else(|| "unknown".to_string())
}

fn is_git_dirty() -> bool {
    Command::new("git")
        .args(&["status", "--porcelain"])
        .output()
        .ok()
        .and_then(|output| {
            if output.status.success() {
                Some(!output.stdout.is_empty())
            } else {
                None
            }
        })
        .unwrap_or(false)
}

fn get_rust_version() -> String {
    Command::new("rustc")
        .arg("--version")
        .output()
        .ok()
        .and_then(|output| {
            if output.status.success() {
                String::from_utf8(output.stdout).ok()
            } else {
                None
            }
        })
        .map(|s| s.trim().to_string())
        .unwrap_or_else(|| "unknown".to_string())
}

fn get_enabled_features() -> String {
    // Get features from CARGO_FEATURE_* environment variables
    let mut features = Vec::new();

    for (key, _) in env::vars() {
        if key.starts_with("CARGO_FEATURE_") {
            let feature = key["CARGO_FEATURE_".len()..].to_lowercase();
            features.push(feature);
        }
    }

    features.sort();
    features.join(",")
}

fn escape_json(s: &str) -> String {
    s.replace('\\', "\\\\")
        .replace('"', "\\\"")
        .replace('\n', "\\n")
        .replace('\r', "\\r")
        .replace('\t', "\\t")
}

fn escape_rust(s: &str) -> String {
    s.replace('\\', "\\\\")
        .replace('"', "\\\"")
        .replace('\n', "\\n")
        .replace('\r', "\\r")
        .replace('\t', "\\t")
}
